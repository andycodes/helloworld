/*
我们可以把前面的算法进行优化。
我们不再检查数字的每一个位，
而是不断把数字最后一个 11 反转，
并把答案加一。当数字变成 00 的时候偶，
我们就知道它没有 11 的位了，此时返回答案。
这里关键的想法是对于任意数字 nn ，将 nn 和 n - 1n?1 做与运算，
会把最后一个 11 的位变成 00 。为什么？考虑 nn 和 n - 1n?1 的
二进制表示。

在二进制表示中，数字 nn 中最低位的 11 总是对应 n - 1n?1 中的 00 。
因此，将 nn 和 n - 1n?1 与运算总是能把 nn 中最低位的 11 变成 00 ，
并保持其他位不变。使用这个小技巧，代码变得非常简单。


统计一个位数组中非0位的数量，数学上称作：
”Hanmming Weight“，汉明重量
*/

int hammingWeight(unsigned int n)
{
    int sum = 0;
    while (n != 0) {
        sum++;
        n &= (n - 1);
    }
    return sum;
}


