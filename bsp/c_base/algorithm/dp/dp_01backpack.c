#include <stdio.h>

#define max(a, b) ((a) > (b) ? (a) : (b))

int main()
{
	int w[5] = { 0 , 2 , 3 , 4 , 5 };			//商品的体积2、3、4、5
	int v[5] = { 0 , 3 , 4 , 5 , 6 };			//商品的价值3、4、5、6
	int bagV = 8;					        //背包大小

        /*
        动态规划表
        dp[ i ][ j ] 表示 在面对第 i 件物品，
        且背包剩余容量为  j 时所能获得的最大价值 */
	int dp[5][9] = { { 0 } };

	for (int i = 1; i <= 4; i++) {
		for (int j = 1; j <= bagV; j++) {
          /* j < w[i] 的情况，这时候背包容量不足以放下第 i 件物品，
          只能选择不拿m[ i ][ j ] = m[ i-1 ][ j ]*/
			if (j < w[i])
				dp[i][j] = dp[i - 1][j];
            /*
 j>=w[i] 的情况，这时背包容量可以放下第 i 件物品，
 我们就要考虑拿这件物品是否能获取更大的价值。
 如果拿取，m[ i ][ j ]=m[ i-1 ][ j-w[ i ] ] + v[ i ]。
 这里的m[ i-1 ][ j-w[ i ] ]指的就是考虑了i-1件物品，
 背包容量为j-w[i]时的最大价值，
 也是相当于为第i件物品腾出了w[i]的空间。
 如果不拿，m[ i ][ j ] = m[ i-1 ][ j ] , 同（1）究竟是拿还是不拿，
 自然是比较这两种情况那种价值最大。
            */
			else
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
		}
	}

	//动态规划表的输出
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 9; j++) {
			printf("%d ",dp[i][j]);
		}
		printf("\n");
	}

	return 0;
}
